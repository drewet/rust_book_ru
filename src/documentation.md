% Документация

Документация является важной частью любого программного проекта, и она
первоклассная в Rust. Давайте поговорим об инструментах Rust, предназначенных
для создания документации к проекту.

> Предупреждение: если вы читаете книгу в формате PDF, ePub или Mobi, в этом
> разделе вы можете встретиться с сломанной разметкой. Если это произошло,
> пожалуйста, используйте HTML-версию. Сожалеем о неудобствах.

## О `rustdoc`

Дистрибутив Rust включает в себя инструмент, `rustdoc`, который генерирует
документацию. `rustdoc` также используется Cargo через `cargo doc`.

Документация может быть сгенерирована двумя методами: из исходного кода, и из
автономных Markdown файлов.

## Документирование исходного кода

Основной способ документирования проекта на Rust заключается в комментировании
исходного кода. Для этой цели вы можете использовать комментарии документации:

```rust,ignore
/// Constructs a new `Rc<T>`.
///
/// # Examples
///
/// ```
/// use std::rc::Rc;
///
/// let five = Rc::new(5);
/// ```
pub fn new(value: T) -> Rc<T> {
    // implementation goes here
}
```

Этот код генерирует документацию, которая выглядит [так][rc-new]. В приведенном
коде реализация метода была заменена на обычный комментарий. Первое, на что
следует обратить внимание в этом примере: используется `///`, а не `//`. Символы
`///` указывают, что это комментарий документации.

Комментарии документации написаны на Markdown.

Rust отслеживает такие комментарии, и использует их при генерировании
документации. Что важно при документировании таких вещей, как перечисления:

```
/// The `Option` type. See [the module level documentation](../) for more.
enum Option<T> {
    /// No value
    None,
    /// Some value `T`
    Some(T),
}
```

Код, приведенный выше работает, а ниже - не работает:

```rust,ignore
/// The `Option` type. See [the module level documentation](../) for more.
enum Option<T> {
    None, /// No value
    Some(T), /// Some value `T`
}
```

Вы получите ошибку:

```text
hello.rs:4:1: 4:2 error: expected ident, found `}`
hello.rs:4 }
           ^
```

Эта досадная [ошибка](https://github.com/rust-lang/rust/issues/22547)
заключается в следующем: комментарии документации распространяются на элементы,
расположенные за ними, а в данном примере нет элемента, расположенного после
последнего комментария.

[rc-new]: http://doc.rust-lang.org/nightly/std/rc/struct.Rc.html#method.new

### Написание комментариев документации

Давайте рассмотрим каждую часть приведенного комментария в деталях:

```
/// Constructs a new `Rc<T>`.
# fn foo() {}
```

Первая строка комментария документации должна представлять из себя краткую
информацию о функциональности. Одно предложение. Только самое основное.
Высокоуровневое.

```
///
/// Other details about constructing `Rc<T>`s, maybe describing complicated
/// semantics, maybe additional options, all kinds of stuff.
///
# fn foo() {}
```

Наш исходный пример включал только строку с краткой информацией, но если бы у
нас было больше информации, о которой следует сказать, мы могли бы добавить эту
информацию в новом параграфе.

#### Специальные разделы

```
/// # Examples
# fn foo() {}
```

Далее идут специальные разделы. Они обозначены с заголовком, который начинается
с `#`. Существуют три вида заголовков, которые обычно используются. Они не
являются каким-либо специальным синтаксисом, на данный момент это просто
соглашение.

```
/// # Panics
# fn foo() {}
```

Невыявляемые случаи неправильного использования функции (так называемые ошибки
программирования) в Rust как правило вызывают панику, которая, в крайнем случае,
убивает весь текущий поток (thread). Если ваша функция имеет подобное
нетривиальное поведение, другими словами, обнаруживает/вызывает панику, то очень
важно задокументировать это.

```
/// # Failures
# fn foo() {}
```

Если ваша функция или метод возвращает `Result<T, E>`, то было бы правильно
описать условия, при которых она возвращает `Err(E)`. Это чуть менее важно, чем
описание `Panics`, потому как неудача кодируется в системе типа, но это не
значит что стоит пренебрегать этим.

```
/// # Safety
# fn foo() {}
```

Если ваша функция является `unsafe`, необходимо пояснить, какие инварианты
вызова должны поддерживаться.

```
/// # Examples
///
/// ```
/// use std::rc::Rc;
///
/// let five = Rc::new(5);
/// ```
# fn foo() {}
```

Раздел `Examples`. Включите в этот раздел один или несколько примеров
использования функции или метода, и ваши пользователи будут вам благодарны за
это. Примеры должны размещаться внутри блока кода, о чем мы сейчас и будем
говорить. Может быть более одного раздела `Examples`:

```
/// # Examples
///
/// Simple `&str` patterns:
///
/// ```
/// let v: Vec<&str> = "Mary had a little lamb".split(' ').collect();
/// assert_eq!(v, vec!["Mary", "had", "a", "little", "lamb"]);
/// ```
///
/// More complex patterns with a lambda:
///
/// ```
/// let v: Vec<&str> = "abc1def2ghi".split(|c: char| c.is_numeric()).collect();
/// assert_eq!(v, vec!["abc", "def", "ghi"]);
/// ```
# fn foo() {}
```

Давайте детально обсудим блоки кода.

#### Блок кода

Чтобы написать код на Rust в комментарии, используйте символы ```:

```
/// ```
/// println!("Hello, world");
/// ```
# fn foo() {}
```

Если вы хотите написать код на любом другом языке (не на Rust), вы можете
добавить аннотацию:

```
/// ```c
/// printf("Hello, world\n");
/// ```
# fn foo() {}
```

Это позволит использовать подсветку синтаксиса, соответствующую тому языку,
который был указан в аннотации. Если же это простой текст, то в аннотации
указывается `text`.

Важно выбрать правильную аннотацию, потому что `rustdoc` использует ее
интересным способом: Rust может выполнять проверку работоспособности примеров на
момент запуска, чтобы они не устаревали. Предположим у вас есть код на C. Если
вы опустите аннотацию, указывающую, что это код на C, то `rustdoc` будет думать,
что это код на Rust, поэтому `rustdoc` будет жаловаться при попытке создания
документации.

## Тесты в документации

Давайте обсудим наш пример документации:

```
/// ```
/// println!("Hello, world");
/// ```
# fn foo() {}
```

Заметьте, что здесь нет нужды в `fn main()` или чем-нибудь подобном. `rustdoc`
автоматически добавит main() обертку вокруг вашего кода в нужном месте.
Например:

```
/// ```
/// use std::rc::Rc;
///
/// let five = Rc::new(5);
/// ```
# fn foo() {}
```

В конечном итоге это будет тест:

```
fn main() {
    use std::rc::Rc;
    let five = Rc::new(5);
}
```

Вот полный алгоритм, который использует `rustdoc` для постобработки примеров:

1. Любые ведущие (leading) атрибуты `#![foo]` остаются без изменений в качестве
   атрибутов контейнера.
2. Будут вставлены некоторые общие `allow` атрибуты, в том числе:
   `unused_variables`, `unused_assignments`, `unused_mut`, `unused_attributes`,
   `dead_code`. Небольшие примеры часто вызывают эти lints.
3. Если пример не содержит `extern crate`, то будет вставлено `extern crate
   <mycrate>;`.
4. Наконец, если пример не содержит `fn main`, то оставшаяся часть текста будет
   обернута в `fn main() { your_code }`

Хотя иногда этого не достаточно. Например, все эти примеры кода с `///`, о
которых мы говорим? Представленный ниже блок кода до обработки `rustdoc`, в виде
простого текста:

```text
/// Some documentation.
# fn foo() {}
```

выглядит иначе, чем после обработки `rustdoc`, в виде сгенерированного вывода:

```
/// Some documentation.
# fn foo() {}
```

Да, именно так: вы можете добавлять строки, которые начинаются с `# `, и они
будут скрыты в выводе, но при этом будут использоваться во время компиляции
кода. Вы можете использовать это в своих интересах. Если в комментарии
документации необходимо обратиться к какой-то функции, то ниже нужно будет
добавить определение этой функции. В то же время, это делается только для того,
чтобы удовлетворить компилятор, поэтому сокрытие ненужных строк в выводе делает
пример более ясным. Вы можете использовать эту технику, чтобы детально объяснять
длинные примеры, сохраняя при этом тестируемость документации. Например, этот
код:

```
let x = 5;
let y = 6;
println!("{}", x + y);
```

Вот объяснение, которое будет сгенерировано:

Сперва мы устанавливаем `x` равным пяти:

```
let x = 5;
# let y = 6;
# println!("{}", x + y);
```

Затем мы устанавливаем `y` равным шести:

```
# let x = 5;
let y = 6;
# println!("{}", x + y);
```

В конце мы печатаем сумму `x` и `y`:

```
# let x = 5;
# let y = 6;
println!("{}", x + y);
```

Вот то же самое объяснение, но в виде простого текста:

> Сперва мы устанавливаем `x` равным пяти:
>
> ```text
> let x = 5;
> # let y = 6;
> # println!("{}", x + y);
> ```
>
> Затем мы устанавливаем `y` равным шести:
>
> ```text
> # let x = 5;
> let y = 6;
> # println!("{}", x + y);
> ```
>
> В конце мы печатаем сумму `x` и `y`:
>
> ```text
> # let x = 5;
> # let y = 6;
> println!("{}", x + y);
> ```

Повторяя все части примера, вы можете быть уверены, что ваш пример
компилируется, а не просто отображает кусоки кода, которые имеют отношение к той
или иной части вашего объяснения.

### Документирование макросов

Вот пример документирования макроса:

```
/// Panic with a given message unless an expression evaluates to true.
///
/// # Examples
///
/// ```
/// # #[macro_use] extern crate foo;
/// # fn main() {
/// panic_unless!(1 + 1 == 2, “Math is broken.”);
/// # }
/// ```
///
/// ```should_panic
/// # #[macro_use] extern crate foo;
/// # fn main() {
/// panic_unless!(true == false, “I’m broken.”);
/// # }
/// ```
#[macro_export]
macro_rules! panic_unless {
    ($condition:expr, $($rest:expr),+) => ({ if ! $condition { panic!($($rest),+); } });
}
# fn main() {}
```

В нем вы можете заметить, три вещи. Во-первых, мы должны собственноручно
добавить строку с `extern crate`, для того, чтобы мы могли указать атрибут
`#[macro_use]`. Во-вторых, мы также собственноручно должны добавить `main()`. И
наконец, разумно будет использовать `#`, чтобы закомментировать все, что мы
добавили в первых двух пунктах, что бы оно не отображалось в генерируемом вводе.

### Запуск тестов в документации

Для запуска тестов можно использовать одну из двух комманд

```bash
$ rustdoc --test path/to/my/crate/root.rs
# or
$ cargo test
```

Все верно, `cargo test` также выполняет тесты, встроенные в документацию. Тем не
менее, `cargo test` не будет тестировать исполняемые контейнеры, только
библиотечные. Это связано с тем, как работает `rustdoc`: он линкует библиотеку в
зависимости от результата тестирования, но в случае с исполняемым файлом, его не
к чему линковать.

Есть еще несколько полезных аннотаций, которые помогают `rustdoc` работать
правильно (корректно) при тестировании кода:

```
/// ```ignore
/// fn foo() {
/// ```
# fn foo() {}
```

Аннотация `ignore` указывает Rust, что код должен быть проигнорирован. Почти во
всех случаях это не то, что вам нужно, так как эта директива носит очень общий
характер. Вместо нее лучше использовать аннотацию `text`, если это не код, или
`#`, чтобы получить рабочий пример, отображающий только ту часть, которая вам
нужна.

```
/// ```should_panic
/// assert!(false);
/// ```
# fn foo() {}
```

Аннотация `should_panic` указывает `rustdoc`, что код должен компилироваться, но
выполнение теста должно завершиться ошибкой.

```
/// ```no_run
/// loop {
///     println!("Hello, world");
/// }
/// ```
# fn foo() {}
```

Аннотация `no_run` указывает, что что код должен компилироваться, но запускать
его на выполнение не требуется. Это важно для таких примеров, которые должны
успешно компилироваться, но которые выполняются в бесконечном цикле! Например:
"Вот как запустить сетевой сервис".

### Документирование модулей

Rust предоставляет еще один вид комментариев документации, `//!`. Этот
комментарий относится не к следующему за ним элементу, а к элементу, который его
включает. Другими словами:

```
mod foo {
    //! This is documentation for the `foo` module.
    //!
    //! # Examples

    // ...
}
```

Приведенный пример демонстрирует наиболее распространенное использование `//!`:
документирование модуля. Если же модуль расположен в файле `foo.rs`, то вы,
открывая его код, часто будете видеть следующее:

```
//! A module for using `foo`s.
//!
//! The `foo` module contains a lot of useful functionality blah blah blah
```

### Стиль комментариев документации

Изучите [RFC 505][rfc505] для получения полных сведений о соглашениях по стилю и
формату документации.

[rfc505]: https://github.com/rust-lang/rfcs/blob/master/text/0505-api-comment-conventions.md

## Другая документация

Все эти правила поведения также применимы и в отношении исходных файлов не на
Rust. Так как комментарии пишутся на Markdown, то часто эти файлы имеют
расширение `.md`.

Когда вы пишете документацию в Markdown файлах, вам не нужно добавлять префикс
комментария документации, `///`. Например:

```
/// # Examples
///
/// ```
/// use std::rc::Rc;
///
/// let five = Rc::new(5);
/// ```
# fn foo() {}
```

преобразуется в

~~~markdown
# Examples

```
use std::rc::Rc;

let five = Rc::new(5);
```
~~~

когда он находится в Markdown файле. Однако есть один недостаток: Markdown файлы
должны иметь заголовок наподобие этого:

```markdown
% The title

This is the example documentation.
```

Строка, начинающаяся с `%`, должна быть самой первой строкой файла.

## Атрибуты `doc`

На более глубоком уровне, комментарии документации - это синтаксический сахар
для атрибутов документации:

```
/// this
# fn foo() {}

#[doc="this"]
# fn bar() {}
```

представленные выше комментарии идентичны, также как и ниже:

```
//! this

#![doc="/// this"]
```

Вы не часто будете видеть этот атрибут, используемый для написания документации,
но он может быть полезен, когда изменения некоторых настроек, или при написании
макроса.

### Ре-экспорт

`rustdoc` будет показывать документацию для public ре-экспорта в двух местах:

```ignore
extern crate foo;

pub use foo::bar;
```

Это создаст документацию для `bar` как в документации для контейнера `foo`, так
и в документации к вашему контейнеру. То есть будет использована одна и та же
документация в обоих местах.

Такое поведение может быть подавлено с помощью `no_inline`:

```ignore
extern crate foo;

#[doc(no_inline)]
pub use foo::bar;
```

### Управление HTML

Вы можете управлять некоторыми аспектами HTML, который генерируется `rustdoc`,
через атрибут `#![doc]`:

```
#![doc(html_logo_url = "http://www.rust-lang.org/logos/rust-logo-128x128-blk-v2.png",
       html_favicon_url = "http://www.rust-lang.org/favicon.ico",
       html_root_url = "http://doc.rust-lang.org/")];
```

В этом примере устанавливается несколько различных опций: логотип, иконка и
корневой URL.

## Опции генерации

`rustdoc` также содержит несколько опций командной строки, для дальнейшей
кастомизации:

- `--html-in-header FILE`: включить содержание FILE в конец `<head>...</head>`
  раздела.
- `--html-before-content FILE`: включить содержание FILE сразу после `<body>`,
  перед отображаемым содержимым (в том числе строки поиска).
- `--html-after-content FILE`: включить содержание FILE после всего
  отображаемого содержимого.

## Замечание по безопасности

Комментарии в Markdown документации помещаются в конечную веб-страницу без
обработки. Будьте осторожны с HTML литералами:

```rust
/// <script>alert(document.cookie)</script>
# fn foo() {}
```
