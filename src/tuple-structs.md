% Кортежные структуры

В Rust есть ещё один тип данных, который представляет собой нечто среднее между
кортежем и структурой. Он называется *кортежной структурой*. Кортежные структуры
именуются, а вот у их полей имён нет:


```{rust}
struct Color(i32, i32, i32);
struct Point(i32, i32, i32);
```

Эти два объекта различны, несмотря на то, что у них одинаковые значения:

```{rust}
# struct Color(i32, i32, i32);
# struct Point(i32, i32, i32);
let black = Color(0, 0, 0);
let origin = Point(0, 0, 0);
```

Почти всегда, вместо кортежной структуры лучше использовать обычную структуру.
Мы бы скорее объявили типы `Color` и `Point` вот так:

```{rust}
struct Color {
    red: i32,
    blue: i32,
    green: i32,
}

struct Point {
    x: i32,
    y: i32,
    z: i32,
}
```

Теперь у нас есть настоящие имена, а не только позиции. Хорошие имена важны, и
при использовании структуры у нас есть эти имена.

Однако, _есть_ один случай, когда кортежные структуры очень полезны. Это
кортежная структура с всего одним элементом. Такое использование называется
*новым типом*, потому что оно позволяет создать новый тип, отличный от типа
значения, содержащегося в кортежной структуре. При этом новый тип обозначает
что-то другое:

```{rust}
struct Inches(i32);

let length = Inches(10);

let Inches(integer_length) = length;
println!("Длина в дюймах: {}", integer_length);
```

Как вы можете видеть в данном примере, извлечь вложенный целый тип можно с
помощью деконструирующего `let`. Мы обсуждали это выше, в разделе "кортежи". В
данном случае, оператор `let Inches(integer_length)` присваивает `10` имени
`integer_length`.
